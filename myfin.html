<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Financial KPIs (Gains x Losses)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 1.5rem;
      background: #f5f5f5;
      color: #222;
    }
    h1 {
      margin-top: 0;
      font-size: 1.6rem;
    }
    .card {
      background: #fff;
      padding: 1rem 1.2rem;
      border-radius: 8px;
      margin-bottom: 1rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    }
    .file-input {
      display: inline-block;
      margin-top: .5rem;
    }
    .kpi-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 0.75rem;
      margin-top: 0.75rem;
    }
    .kpi {
      padding: 0.75rem;
      border-radius: 6px;
      background: #fafafa;
      border: 1px solid #e0e0e0;
    }
    .kpi-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: .03em;
      opacity: 0.7;
      margin-bottom: 0.2rem;
    }
    .kpi-value {
      font-size: 1.1rem;
      font-weight: 600;
    }
    .kpi-positive { color: #1b7e39; }
    .kpi-negative { color: #b3261e; }
    .kpi-neutral { color: #1f2a33; }

    .error {
      color: #b3261e;
      margin-top: 0.5rem;
      font-size: 0.9rem;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0.5rem;
      font-size: 0.9rem;
    }
    th, td {
      padding: 0.4rem 0.5rem;
      border-bottom: 1px solid #e0e0e0;
      text-align: right;
      white-space: nowrap;
    }
    th:first-child, td:first-child {
      text-align: left;
    }
    th {
      background: #f0f0f0;
      font-weight: 600;
    }

    .tables-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 1rem;
      margin-top: 0.5rem;
    }

    .hint {
      font-size: 0.85rem;
      color: #555;
      margin-top: 0.4rem;
    }
    .link-button {
      border: none;
      background: none;
      padding: 0;
      font: inherit;
      color: #1a73e8;
      cursor: pointer;
    }
    .link-button:hover {
      text-decoration: underline;
    }
    tr.is-filtered {
      background: #e8f0fe;
    }
    .table-empty {
      text-align: center;
      font-style: italic;
      color: #666;
    }
    .trend-icon {
      margin-left: 0.35rem;
      font-size: 0.85rem;
      font-weight: 600;
      display: inline-block;
    }
    .trend-up {
      color: #1a73e8;
    }
    .trend-down {
      color: #d93025;
    }
    .hierarchy-table table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0.5rem;
    }
    .hierarchy-table th,
    .hierarchy-table td {
      padding: 0.4rem 0.5rem;
      border-bottom: 1px solid #e0e0e0;
      text-align: right;
      white-space: nowrap;
    }
    .hierarchy-table th:first-child,
    .hierarchy-table td:first-child {
      text-align: left;
    }
    .hierarchy-row.year-row {
      background: #f3f4f6;
      font-weight: 600;
    }
    .hierarchy-row.month-row {
      background: #fafafa;
    }
    .hierarchy-row .level-label {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }
    .tree-toggle {
      border: none;
      background: none;
      cursor: pointer;
      font-size: 0.9rem;
      padding: 0.1rem;
      display: inline-flex;
      align-items: center;
    }
    .tree-toggle:focus-visible {
      outline: 2px solid #1a73e8;
    }
    .level-label .indent {
      display: inline-block;
      width: 1rem;
    }
    .crud-form {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 0.75rem;
      margin-bottom: 0.75rem;
    }
    .crud-form label {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: .03em;
      color: #555;
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }
    .crud-form input {
      padding: 0.4rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      font: inherit;
    }
    .crud-actions {
      margin-bottom: 0.5rem;
    }
    #crudTable {
      width: 100%;
      border-collapse: collapse;
    }
    #crudTable th,
    #crudTable td {
      padding: 0.35rem 0.5rem;
      border-bottom: 1px solid #e0e0e0;
      text-align: right;
    }
    #crudTable th:first-child,
    #crudTable td:first-child {
      text-align: left;
    }
    .crud-table-actions button {
      margin-right: 0.3rem;
    }
    .chart-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin: 0.4rem auto 0.6rem;
      justify-content: center;
    }
    .chart-controls button {
      border: 1px solid #d0d7de;
      background: #fff;
      color: #1f2933;
      padding: 0.25rem 0.75rem;
      border-radius: 999px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: background 0.2s, color 0.2s;
    }
    .chart-controls button.active {
      background: #1a73e8;
      color: #fff;
      border-color: #1a73e8;
    }
    .chart-legend {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 1rem;
      font-size: 0.85rem;
      color: #1f2933;
      margin-bottom: 0.8rem;
    }
    .chart-legend .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
    }
    .chart-legend .legend-swatch {
      width: 18px;
      height: 3px;
      border-radius: 999px;
      display: inline-block;
    }
    #trendChart {
      width: 100%;
      display: block;
    }
  </style>
  <!-- SheetJS (XLSX) CDN -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
  <h1>Loba's Finances</h1>

  <div class="card">
    <p><strong>Step 1:</strong> Load the published Google Sheets data.</p>
    <p class="hint">
      <!-- The sheet should contain the columns <code>Date</code>, <code>Single</code>, <code>IRA</code>, and <code>Trust Acct</code> in the first row.
      <br />
      The app uses public proxies so you can open it directly on mobile (no local server required).
      <br /> -->
      If the online fetch fails, upload the <code>.xlsx</code> or <code>.csv</code> file below.
    </p>
    <button id="refreshBtn" class="link-button" style="font-size:1rem;">↻ Refresh from Google Sheets</button>
    <div>
      <label class="hint" for="fileInput">or choose a local file:</label>
      <input class="file-input" type="file" id="fileInput" accept=".xlsx,.xls,.csv" />
    </div>
    <div id="error" class="error"></div>
    <details style="margin-top:0.6rem;">
      <summary>Debug log</summary>
      <pre id="debugLog" style="background:#111;color:#eee;padding:0.5rem;border-radius:6px;max-height:200px;overflow:auto;margin:0.4rem 0 0 0;"></pre>
    </details>
  </div>

  <div class="card">
    <h2>Overall Summary</h2>
    <div class="kpi-grid">
      <div class="kpi">
        <div class="kpi-title">Total Gained</div>
        <div id="totalGain" class="kpi-value kpi-positive">$0.00</div>
      </div>
      <div class="kpi">
        <div class="kpi-title">Total Lost</div>
        <div id="totalLoss" class="kpi-value kpi-negative">$0.00</div>
      </div>
      <div class="kpi">
        <div class="kpi-title">Net Result</div>
        <div id="netResult" class="kpi-value kpi-neutral">$0.00</div>
      </div>
      <div class="kpi">
        <div class="kpi-title"># of Entries</div>
        <div id="countTx" class="kpi-value kpi-neutral">0</div>
      </div>
    </div>
  </div>

  <div class="card">
    <h2>Balances by Investment</h2>
    <p class="hint">Latest entry for each type and the variation versus the previous record.</p>
    <div id="investmentGrid" class="kpi-grid">
      <div class="kpi">
        <div class="kpi-title">Awaiting file</div>
        <div class="kpi-value kpi-neutral">--</div>
      </div>
    </div>
  </div>

  <div class="card">
    <h2>Totals by Year / Month / Week / Day</h2>
    <p class="hint">Expand rows to drill down through the timeline.</p>
    <div class="hierarchy-table">
      <table>
        <thead>
          <tr>
            <th>Period</th>
            <th>Single</th>
            <th>IRA</th>
            <th>Trust Acct</th>
            <th>Total</th>
            <th>Diff</th>
          </tr>
        </thead>
        <tbody id="hierarchyBody">
          <tr>
            <td colspan="6" class="table-empty">Awaiting data...</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>

  <div class="card">
    <h2>Manage Entries Locally</h2>
    <p class="hint">Edits here are local; after adjusting, export the CSV and update your Google Sheet.</p>
    <form id="entryForm" class="crud-form">
      <label>Date
        <input type="date" id="formDate" required />
      </label>
      <label>Single
        <input type="text" inputmode="decimal" id="formSingle" required />
      </label>
      <label>IRA
        <input type="text" inputmode="decimal" id="formIRA" required />
      </label>
      <label>Trust Acct
        <input type="text" inputmode="decimal" id="formTrust" required />
      </label>
      <div style="display:flex;align-items:center;gap:0.5rem;">
        <button type="submit" id="submitEntryBtn">Add entry</button>
        <button type="button" id="cancelEditBtn" class="link-button" style="padding:0;">Cancel edit</button>
      </div>
    </form>
    <div class="crud-actions">
      <button id="downloadCsvBtn">Download updated CSV</button>
    </div>
    <button type="button" id="toggleEntriesBtn" class="link-button" style="display:none;margin-bottom:0.4rem;">Show more ▾</button>
    <table id="crudTable">
      <thead>
        <tr>
          <th>Date</th>
          <th>Single</th>
          <th>IRA</th>
          <th>Trust</th>
          <th>Total</th>
          <th>Diff</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td colspan="7" class="table-empty">Load data to begin editing.</td>
        </tr>
      </tbody>
    </table>
  </div>

  <div class="card">
    <h2>Monthly Trend</h2>
    <p class="hint">Track how the consolidated total evolved over time.</p>
    <div class="chart-controls" id="chartFilters">
      <button type="button" data-range="1m">1M</button>
      <button type="button" data-range="3m">3M</button>
      <button type="button" data-range="6m">6M</button>
      <button type="button" data-range="1y">1Y</button>
      <button type="button" data-range="ytd">This Year</button>
      <button type="button" data-range="all" class="active">All</button>
    </div>
    <div class="chart-legend" id="chartLegend"></div>
    <div class="chart-wrapper" style="position:relative;">
      <canvas id="trendChart" height="320"></canvas>
      <div id="chartTooltip" style="position:absolute;pointer-events:none;background:#111827;color:#fff;padding:0.5rem 0.75rem;font-size:0.85rem;border-radius:6px;box-shadow:0 4px 12px rgba(0,0,0,0.15);opacity:0;transition:opacity 0.15s;"></div>
    </div>
  </div>

  <script>
    const fileInput = document.getElementById('fileInput');
    const errorDiv = document.getElementById('error');
    const refreshBtn = document.getElementById('refreshBtn');
    const debugLogEl = document.getElementById('debugLog');
    const hierarchyBody = document.getElementById('hierarchyBody');
    const entryForm = document.getElementById('entryForm');
    const submitEntryBtn = document.getElementById('submitEntryBtn');
    const cancelEditBtn = document.getElementById('cancelEditBtn');
    const downloadCsvBtn = document.getElementById('downloadCsvBtn');
    const crudTableBody = document.querySelector('#crudTable tbody');
    const toggleEntriesBtn = document.getElementById('toggleEntriesBtn');
    const formDate = document.getElementById('formDate');
    const formSingle = document.getElementById('formSingle');
    const formIRA = document.getElementById('formIRA');
    const formTrust = document.getElementById('formTrust');
    const chartCanvas = document.getElementById('trendChart');
    const chartFilters = document.getElementById('chartFilters');
    const chartLegend = document.getElementById('chartLegend');
    const chartTooltip = document.getElementById('chartTooltip');
    const SHEET_URLS = [
      'https://docs.google.com/spreadsheets/d/e/2PACX-1vQ3AvzjoSaklTNllWooFtOT8TWNA0LA_L_-5eRGvYSbGnNgO2E4qLCNJwUtlY77u-ZNyuSyYsGi6T0x/pub?gid=0&single=true&output=csv',
      'https://cors.isomorphic-git.org/https://docs.google.com/spreadsheets/d/e/2PACX-1vQ3AvzjoSaklTNllWooFtOT8TWNA0LA_L_-5eRGvYSbGnNgO2E4qLCNJwUtlY77u-ZNyuSyYsGi6T0x/pub?gid=0&single=true&output=csv',
      'https://r.jina.ai/https://docs.google.com/spreadsheets/d/e/2PACX-1vQ3AvzjoSaklTNllWooFtOT8TWNA0LA_L_-5eRGvYSbGnNgO2E4qLCNJwUtlY77u-ZNyuSyYsGi6T0x/pub?gid=0&single=true&output=csv'
    ];
    const SHEET_GVIZ_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQ3AvzjoSaklTNllWooFtOT8TWNA0LA_L_-5eRGvYSbGnNgO2E4qLCNJwUtlY77u-ZNyuSyYsGi6T0x/gviz/tq?gid=0&headers=1';
    const GOOGLE_SCRIPT_ENDPOINT = 'https://script.google.com/macros/s/AKfycbztZXV8nPICz9kekS8YIu3ytmdi_jhyJKna5h_E0rXKgDitS8Lca4AgmxxnXkibw_sw/exec';
    const GOOGLE_SCRIPT_TOKEN = 'zYK492Vp6zanaMEAHQ6dlEZLHnVtEO7cQV9jjE';
    const investmentDefinitions = [
      { key: 'single', labels: ['single'], display: 'Single' },
      { key: 'ira', labels: ['ira'], display: 'IRA' },
      { key: 'trust', labels: ['trust acct', 'trust account', 'trust'], display: 'Trust Acct' }
    ];
    let hierarchyData = [];
    let currentRecords = [];
    let currentInvestments = investmentDefinitions.map(def => ({ key: def.key, display: def.display }));
    const expandedYears = new Set();
    const expandedMonths = new Set();
    const expandedWeeks = new Set();
    let editingRecordIndex = null;
    let monthlySeries = [];
    let currentChartRange = 'all';
    const MAX_CRUD_VISIBLE_ROWS = 5;
    let showAllCrudRows = false;
    const metricConfigs = [
      { key: 'single', label: 'Single', color: '#1a73e8', lineWidth: 2 },
      { key: 'ira', label: 'IRA', color: '#f97316', lineWidth: 2 },
      { key: 'trust', label: 'Trust', color: '#16a34a', lineWidth: 2 },
      { key: 'total', label: 'Total', color: '#111827', lineWidth: 3.5 }
    ];

    if (toggleEntriesBtn) {
      toggleEntriesBtn.setAttribute('aria-controls', 'crudTable');
    }

    refreshBtn?.addEventListener('click', loadGoogleSheet);
    fileInput?.addEventListener('change', handleLocalFile);
    hierarchyBody?.addEventListener('click', handleHierarchyClick);
    entryForm?.addEventListener('submit', handleEntrySubmit);
    cancelEditBtn?.addEventListener('click', resetFormState);
    downloadCsvBtn?.addEventListener('click', handleDownloadCsv);
    crudTableBody?.addEventListener('click', handleCrudTableClick);
    toggleEntriesBtn?.addEventListener('click', () => {
      showAllCrudRows = !showAllCrudRows;
      renderCrudTable();
    });
    chartFilters?.addEventListener('click', handleChartFilterClick);
    [formSingle, formIRA, formTrust].forEach(input => attachCurrencyMask(input));
    loadGoogleSheet();
    window.addEventListener('resize', () => renderTrendChart());
    chartCanvas?.addEventListener('mousemove', handleChartMouseMove);
    chartCanvas?.addEventListener('mouseleave', () => hideTooltip());
    currentChartRange = chartFilters?.querySelector('.active')?.dataset.range || 'all';
    renderChartLegend();

    async function loadGoogleSheet() {
      clearDebug();
      logDebug('Loading data from Google Sheets (CSV + JSONP fallback)...');
      showError('Loading data from Google Sheets...');
      try {
        const rows = await loadRowsFromPublishedSheet();
        logDebug(`Received ${rows.length - 1} rows from online sheet.`);
        processRows(rows);
        showError('');
      } catch (err) {
        console.error(err);
        showError(`Failed to load Google Sheets data. ${err.message || ''}`);
      }
    }

    async function loadRowsFromPublishedSheet() {
      let csvErrors = null;
      try {
        const csvText = await fetchSheetCSV();
        if (csvText) {
          logDebug('CSV fetch succeeded, parsing...');
          return convertCSVToRows(csvText);
        }
      } catch (err) {
        csvErrors = err;
        logDebug(`CSV fetch failed: ${err.message || err}`);
      }
      const jsonpRows = await loadRowsViaJSONP();
      if (jsonpRows && jsonpRows.length) {
        if (csvErrors) {
          console.warn('CSV fetch failed, using JSONP fallback:', csvErrors);
        }
        return jsonpRows;
      }
      throw csvErrors || new Error('Unable to fetch spreadsheet data.');
    }

    async function fetchSheetCSV() {
      const errors = [];
      for (const url of SHEET_URLS) {
        try {
            logDebug(`Trying CSV URL: ${url}`);
            const response = await fetch(url, { mode: 'cors' });
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const text = await response.text();
            if (!text.trim()) throw new Error('Empty response');
            logDebug(`Success from CSV URL: ${url} (bytes=${text.length})`);
            return text;
        } catch (err) {
            errors.push(`${url}: ${err.message || err}`);
            logDebug(`Failed CSV URL: ${url} -> ${err.message || err}`);
        }
      }
      throw new Error(`CSV attempts failed. Details: ${errors.join(' | ')}`);
    }

    function convertCSVToRows(csvText) {
      const sanitized = csvText.replace(/^\uFEFF/, '');
      const delimiter = detectDelimiter(sanitized);
      const parsed = simpleCSVParse(sanitized, delimiter);
      if (parsed.length) {
        logDebug(`CSV parsed with delimiter "${delimiter}". Rows: ${parsed.length - 1}`);
        return parsed;
      }
      const workbook = XLSX.read(csvText, { type: 'string', raw: true });
      const firstSheetName = workbook.SheetNames[0];
      const ws = workbook.Sheets[firstSheetName];
      logDebug('CSV parser empty, falling back to SheetJS parse.');
      return XLSX.utils.sheet_to_json(ws, { header: 1, raw: true });
    }

    function detectDelimiter(text) {
      const lines = text.split(/\r?\n/).filter(line => line.trim() !== '');
      if (!lines.length) return ',';
      const sample = lines[0];
      const commaCount = (sample.match(/,/g) || []).length;
      const semicolonCount = (sample.match(/;/g) || []).length;
      const tabCount = (sample.match(/\t/g) || []).length;
      let delimiter = ',';
      let max = commaCount;
      if (semicolonCount > max) {
        delimiter = ';';
        max = semicolonCount;
      }
      if (tabCount > max) {
        delimiter = '\t';
      }
      return delimiter;
    }

    function simpleCSVParse(text, delimiter) {
      const rows = [];
      let current = [];
      let value = '';
      let insideQuotes = false;

      const pushValue = () => {
        current.push(value);
        value = '';
      };

      const pushRow = () => {
        if (current.length || value) {
          // ensures last value added before pushing row
          rows.push(current.slice());
        }
        current = [];
      };

      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        if (char === '"') {
          if (insideQuotes && text[i + 1] === '"') {
            value += '"';
            i++;
          } else {
            insideQuotes = !insideQuotes;
          }
        } else if (char === delimiter && !insideQuotes) {
          pushValue();
        } else if ((char === '\n' || char === '\r') && !insideQuotes) {
          if (char === '\r' && text[i + 1] === '\n') i++;
          pushValue();
          pushRow();
        } else {
          value += char;
        }
      }
      if (value.length || current.length) {
        pushValue();
        pushRow();
      }

      return rows.filter(row => row.some(cell => cell !== ''));
    }

    function loadRowsViaJSONP() {
      logDebug('Falling back to JSONP endpoint...');
      return new Promise((resolve, reject) => {
        const callbackName = `sheetCallback_${Date.now()}`;
        const script = document.createElement('script');
        const cleanup = () => {
          if (script.parentNode) script.parentNode.removeChild(script);
          delete window[callbackName];
        };

        window[callbackName] = (response) => {
          cleanup();
          try {
            const rows = convertGvizResponseToRows(response);
            logDebug(`JSONP returned ${rows.length} rows.`);
            resolve(rows);
          } catch (err) {
            logDebug(`JSONP parsing error: ${err.message || err}`);
            reject(err);
          }
        };

        script.onerror = () => {
          cleanup();
          logDebug('JSONP script failed to load.');
          reject(new Error('JSONP request failed.'));
        };

        const tqx = encodeURIComponent(`out:json;responseHandler=${callbackName};reqId=${Date.now()}`);
        script.src = `${SHEET_GVIZ_URL}&tq=&tqx=${tqx}`;
        script.async = true;
        document.body.appendChild(script);
      });
    }

    function convertGvizResponseToRows(response) {
      if (!response || response.status !== 'ok' || !response.table) {
        throw new Error('Unexpected JSONP response.');
      }
      const headers = response.table.cols.map(col => (col?.label || col?.id || '').trim());
      const rows = [headers];
      for (const row of response.table.rows) {
        if (!row || !row.c) continue;
        const cells = [];
        for (let i = 0; i < headers.length; i++) {
          const cell = row.c[i];
          if (!cell) {
            cells.push('');
          } else if (cell.f != null) {
            cells.push(cell.f);
          } else if (cell.v != null) {
            cells.push(cell.v);
          } else {
            cells.push('');
          }
        }
        rows.push(cells);
      }
      return rows;
    }

    function handleLocalFile(event) {
      const file = event.target.files && event.target.files[0];
      if (!file) return;

      const isCSV = /\.csv$/i.test(file.name);
      showError(`Loading local ${isCSV ? 'CSV' : 'Excel'} file...`);
      logDebug(`Loading local file: ${file.name} (${file.size} bytes)`); 

      const reader = new FileReader();
      reader.onload = function(evt) {
        try {
          const data = evt.target?.result;
          if (!data) throw new Error('Unable to read file data.');
          let workbook;
          if (isCSV) {
            workbook = XLSX.read(data, { type: 'string', raw: true });
          } else {
            workbook = XLSX.read(data, { type: 'array', raw: true });
          }
          const firstSheetName = workbook.SheetNames[0];
          const ws = workbook.Sheets[firstSheetName];
          const rows = XLSX.utils.sheet_to_json(ws, { header: 1, raw: true });
          logDebug(`Local file parsed with ${rows.length - 1} data rows.`);
          processRows(rows);
          showError('');
        } catch (err) {
          console.error(err);
          showError(`Failed to read local file. ${err.message || ''}`);
        } finally {
          event.target.value = '';
        }
      };
      reader.onerror = function(err) {
        console.error(err);
        showError('Failed to read local file.');
        event.target.value = '';
      };
      if (isCSV) {
        reader.readAsText(file);
      } else {
        reader.readAsArrayBuffer(file);
      }
    }

    function processRows(rows) {
      if (!rows.length) {
        showError('Empty spreadsheet.');
        return;
      }

      const headerRowIndex = findHeaderRowIndex(rows);
      if (headerRowIndex === -1) {
        logDebug(`Could not locate header row. First row sample: ${JSON.stringify(rows[0])}`);
        showError('Could not find the header row with "Date".');
        return;
      }

      const headers = rows[headerRowIndex].map(h => String(h || '').trim());
      const normalizedHeaders = headers.map(normalizeHeader);
      const dateIdx = findHeaderIndex(normalizedHeaders, ['date', 'data']);

      if (dateIdx === -1) {
        logDebug(`Header row content: ${JSON.stringify(headers)}`);
        showError('Could not find the "Date" column on the first row.');
        return;
      }

      const dataRows = rows.slice(headerRowIndex + 1);
      logDebug(`Processing ${dataRows.length} data rows with ${headers.length} columns (header at index ${headerRowIndex}).`);

      const detectedInvestments = investmentDefinitions
        .map(def => {
          const idx = findHeaderIndex(normalizedHeaders, def.labels);
          if (idx === -1) return null;
          return {
            ...def,
            idx,
            display: headers[idx] || def.display
          };
        })
        .filter(Boolean);

      if (!detectedInvestments.length) {
        showError('Could not find the investment columns (Single, IRA, Trust Acct).');
        return;
      }

      const records = [];
      for (let i = 0; i < dataRows.length; i++) {
        const row = dataRows[i];
        if (!row || row.length === 0) continue;

        const rawDate = row[dateIdx];
        if (rawDate == null || rawDate === '') continue;
        const date = parseExcelDate(rawDate);
        if (!date) continue;

        const record = { date };
        let hasValue = false;
        let hasZeroValue = false;

        for (const col of detectedInvestments) {
          const val = toNumber(row[col.idx]);
          record[col.key] = val;
          if (Number.isFinite(val)) {
            hasValue = true;
            if (val === 0) {
              hasZeroValue = true;
            }
          }
        }

        if (!hasValue || hasZeroValue) continue;

        records.push(record);
      }

      if (!records.length) {
        showError('No valid rows found (invalid date/value).');
        return;
      }
      logDebug(`Built ${records.length} normalized records.`);

      currentInvestments = detectedInvestments.length
        ? detectedInvestments.map(({ key, display }) => ({ key, display }))
        : investmentDefinitions.map(def => ({ key: def.key, display: def.display }));
      applyRecords(records);
    }

    function applyRecords(records) {
      const normalized = records
        .map(rec => ({
          date: rec.date instanceof Date ? new Date(rec.date) : parseExcelDate(rec.date),
          single: parseCurrencyToNumber(rec.single),
          ira: parseCurrencyToNumber(rec.ira),
          trust: parseCurrencyToNumber(rec.trust)
        }))
        .filter(rec => {
          if (!rec.date || isNaN(rec.date.getTime())) return false;
          const hasZeroValue = ['single', 'ira', 'trust'].some(key => Number.isFinite(rec[key]) && rec[key] === 0);
          return !hasZeroValue;
        });

      const uniqueByDate = new Map();
      for (let i = normalized.length - 1; i >= 0; i--) {
        const rec = normalized[i];
        const key = formatDateForInput(rec.date);
        if (!key || uniqueByDate.has(key)) continue;
        uniqueByDate.set(key, rec);
      }
      const deduped = Array.from(uniqueByDate.values());

      deduped.sort((a, b) => a.date - b.date);
      let previousTotal = null;
      for (const rec of deduped) {
        const computedTotal = ['single', 'ira', 'trust'].reduce((sum, key) => sum + (Number.isFinite(rec[key]) ? rec[key] : 0), 0);
        rec.total = computedTotal;
        if (previousTotal == null) {
          rec.diff = 0;
        } else {
          rec.diff = computedTotal - previousTotal;
        }
        previousTotal = computedTotal;
      }

      currentRecords = deduped.map(rec => ({ ...rec }));
      const movements = deduped.map(rec => ({
        date: rec.date,
        amount: Number.isFinite(rec.diff) ? rec.diff : 0
      }));

      calcularKPIs(movements, deduped.length);
      atualizarInvestimentos(deduped, currentInvestments);
      monthlySeries = buildMonthlySeries(deduped);
      renderTrendChart();
      expandedYears.clear();
      expandedMonths.clear();
      expandedWeeks.clear();
      hierarchyData = buildHierarchy(deduped);
      renderHierarchy();
      renderCrudTable();
      resetFormState();
    }

    function showError(msg) {
      if (msg) console.error('[Finance Dashboard]', msg);
      errorDiv.textContent = msg;
      if (msg) logDebug(`ERROR: ${msg}`);
    }

    function logDebug(message) {
      if (!debugLogEl) return;
      const timestamp = new Date().toISOString();
      debugLogEl.textContent += `[${timestamp}] ${message}\n`;
    }

    function clearDebug() {
      if (debugLogEl) debugLogEl.textContent = '';
    }

    function parseExcelDate(val) {
      if (val instanceof Date) {
        return val;
      }
      if (typeof val === 'string') {
        const trimmed = val.trim();
        if (!trimmed) return null;
        const isoDateMatch = trimmed.match(/^(\d{4})-(\d{2})-(\d{2})$/);
        if (isoDateMatch) {
          const [, yearStr, monthStr, dayStr] = isoDateMatch;
          const date = new Date(Number(yearStr), Number(monthStr) - 1, Number(dayStr));
          return isNaN(date.getTime()) ? null : date;
        }
        const tryNative = new Date(trimmed);
        if (!isNaN(tryNative.getTime())) {
          return tryNative;
        }
        const numericCandidate = Number(trimmed.replace(',', '.'));
        if (Number.isFinite(numericCandidate)) {
          val = numericCandidate;
        } else {
          return null;
        }
      }
      if (typeof val === 'number') {
        const excelEpoch = new Date(Date.UTC(1899, 11, 30));
        const date = new Date(excelEpoch.getTime() + val * 86400000);
        if (isNaN(date.getTime())) return null;
        return date;
      }
      return null;
    }

    function normalizeHeader(header) {
      return String(header || '').trim().toLowerCase().replace(/\s+/g, ' ');
    }

    function findHeaderRowIndex(rows) {
      for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        if (!row || !row.length) continue;
        const normalized = row.map(normalizeHeader);
        if (findHeaderIndex(normalized, ['date', 'data']) !== -1) {
          return i;
        }
      }
      return -1;
    }

    function findHeaderIndex(headers, targets) {
      if (!Array.isArray(headers)) return -1;
      for (let i = 0; i < headers.length; i++) {
        if (targets.includes(headers[i])) {
          return i;
        }
      }
      return -1;
    }

    function toNumber(value) {
      if (value === null || value === undefined || value === '') return null;
      if (typeof value === 'number') {
        return Number.isFinite(value) ? value : null;
      }
      let normalized = String(value).trim();
      if (!normalized) return null;
      let negative = false;
      if (/^\(.*\)$/.test(normalized)) {
        negative = true;
        normalized = normalized.slice(1, -1);
      }
      normalized = normalized.replace(/\s+/g, '');
      normalized = normalized.replace(/,/g, '');
      const num = Number(normalized);
      if (!Number.isFinite(num)) return null;
      return negative ? -num : num;
    }

    function calcularKPIs(records, totalSnapshots) {
      let totalGain = 0;
      let totalLoss = 0;
      let net = 0;

      for (const r of records) {
        const amount = r.amount;
        net += amount;
        if (amount > 0) totalGain += amount;
        if (amount < 0) totalLoss += amount;
      }

      document.getElementById('totalGain').textContent = formatUSD(totalGain);
      document.getElementById('totalLoss').textContent = formatUSD(totalLoss);
      document.getElementById('netResult').textContent = formatUSD(net);
      document.getElementById('countTx').textContent = totalSnapshots.toString();
    }

    function getISOWeekKey(date) {
      const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
      const dayNum = d.getUTCDay() || 7;
      d.setUTCDate(d.getUTCDate() + 4 - dayNum);
      const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
      const weekNo = Math.ceil(((d - yearStart) / 86400000 + 1) / 7);
      const year = d.getUTCFullYear();
      return `${year}-W${String(weekNo).padStart(2, '0')}`;
    }

    function getISOWeekNumber(date) {
      const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
      const dayNum = d.getUTCDay() || 7;
      d.setUTCDate(d.getUTCDate() + 4 - dayNum);
      const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
      return Math.ceil(((d - yearStart) / 86400000 + 1) / 7);
    }

    function getMonthKey(date) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      return `${year}-${month}`;
    }

    function formatMonthKey(key) {
      const [y, m] = key.split('-');
      const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      const idx = parseInt(m, 10) - 1;
      const labelMonth = monthNames[idx] || m;
      return `${labelMonth}/${y}`;
    }

    function formatUSD(value) {
      if (!Number.isFinite(value)) return '-';
      return value.toLocaleString('en-US', {
        style: 'currency',
        currency: 'USD'
      });
    }

    function parseCurrencyToNumber(value) {
      if (value === null || value === undefined || value === '') return null;
      if (typeof value === 'number') {
        return Number.isFinite(value) ? value : null;
      }
      let normalized = String(value).trim();
      if (!normalized) return null;

      let negative = false;
      if (/^\(.*\)$/.test(normalized)) {
        negative = true;
        normalized = normalized.slice(1, -1);
      }
      if (normalized.includes('-')) {
        negative = true;
        normalized = normalized.replace(/-/g, '');
      }

      normalized = normalized.replace(/[^\d.,]/g, '');
      if (!normalized) return null;

      const lastDot = normalized.lastIndexOf('.');
      const lastComma = normalized.lastIndexOf(',');
      const dotDigits = lastDot !== -1 ? normalized.length - lastDot - 1 : 0;
      const commaDigits = lastComma !== -1 ? normalized.length - lastComma - 1 : 0;
      const dotIsDecimal = lastDot !== -1 && dotDigits > 0 && dotDigits <= 2;
      const commaIsDecimal = lastComma !== -1 && commaDigits > 0 && commaDigits <= 2;

      let decimalDigits = 0;
      if (dotIsDecimal && (!commaIsDecimal || lastDot > lastComma)) {
        decimalDigits = dotDigits;
      } else if (commaIsDecimal) {
        decimalDigits = commaDigits;
      } else {
        decimalDigits = 0;
      }

      const digitsOnly = normalized.replace(/[^0-9]/g, '');
      if (!digitsOnly) return null;

      let numericString = digitsOnly;
      if (decimalDigits > 0) {
        if (decimalDigits >= digitsOnly.length) {
          numericString = `0.${digitsOnly.padStart(decimalDigits, '0')}`;
        } else {
          const splitIndex = digitsOnly.length - decimalDigits;
          numericString = `${digitsOnly.slice(0, splitIndex)}.${digitsOnly.slice(splitIndex)}`;
        }
      }

      const num = Number(numericString);
      if (!Number.isFinite(num)) return null;
      return negative ? -num : num;
    }

    function attachCurrencyMask(input) {
      if (!input) return;

      const sanitizeInput = () => {
        const cleaned = input.value.replace(/[^\d.,\-()]/g, '');
        if (cleaned !== input.value) {
          input.value = cleaned;
        }
      };

      const applyMask = () => {
        const numericValue = parseCurrencyToNumber(input.value);
        if (numericValue === null) {
          delete input.dataset.rawValue;
          input.value = '';
          return;
        }
        input.dataset.rawValue = numericValue.toString();
        input.value = formatUSD(numericValue);
      };

      input.addEventListener('input', sanitizeInput);
      input.addEventListener('blur', applyMask);
      input.addEventListener('change', applyMask);
      input.addEventListener('focus', () => {
        requestAnimationFrame(() => {
          if (input.value) {
            input.select();
          }
        });
      });

      if (input.value) {
        applyMask();
      }
    }

    function atualizarInvestimentos(records, investments) {
      const grid = document.getElementById('investmentGrid');
      grid.innerHTML = '';

      if (!records.length) {
        grid.innerHTML = `
          <div class="kpi">
            <div class="kpi-title">No data</div>
            <div class="kpi-value kpi-neutral">--</div>
          </div>
        `;
        return;
      }

      const latest = records[records.length - 1];
      const fragment = document.createDocumentFragment();

      for (const col of investments) {
        const value = latest[col.key];
        if (!Number.isFinite(value)) continue;
        const card = document.createElement('div');
        card.className = 'kpi';
        card.innerHTML = `
          <div class="kpi-title">${col.display}</div>
          <div class="kpi-value kpi-neutral">${formatUSD(value)}</div>
        `;
        fragment.appendChild(card);
      }

      if (Number.isFinite(latest.total)) {
        const totalCard = document.createElement('div');
        totalCard.className = 'kpi';
        totalCard.innerHTML = `
          <div class="kpi-title">Consolidated total</div>
          <div class="kpi-value kpi-neutral">${formatUSD(latest.total)}</div>
        `;
        fragment.appendChild(totalCard);
      }

      const diffValue = Number.isFinite(latest.diff) ? latest.diff : 0;
      const diffClass = diffValue > 0 ? 'kpi-positive' : diffValue < 0 ? 'kpi-negative' : 'kpi-neutral';
      const diffCard = document.createElement('div');
      diffCard.className = 'kpi';
      diffCard.innerHTML = `
        <div class="kpi-title">Diff vs previous</div>
        <div class="kpi-value ${diffClass}">${formatUSD(diffValue)}</div>
      `;
      fragment.appendChild(diffCard);

      if (!fragment.childNodes.length) {
        grid.innerHTML = `
          <div class="kpi">
            <div class="kpi-title">No values</div>
            <div class="kpi-value kpi-neutral">--</div>
          </div>
        `;
      } else {
        grid.appendChild(fragment);
      }
    }

    function buildMonthlySeries(records) {
      const map = new Map();
      for (const rec of records) {
        if (!(rec.date instanceof Date) || isNaN(rec.date.getTime())) continue;
        const key = `${rec.date.getFullYear()}-${String(rec.date.getMonth() + 1).padStart(2, '0')}`;
        const existing = map.get(key);
        if (!existing || rec.date > existing.date) {
          map.set(key, {
            key,
            date: new Date(rec.date),
            label: rec.date.toLocaleString('en-US', { month: 'short', year: 'numeric' }),
            single: Number.isFinite(rec.single) ? rec.single : null,
            ira: Number.isFinite(rec.ira) ? rec.ira : null,
            trust: Number.isFinite(rec.trust) ? rec.trust : null,
            total: Number.isFinite(rec.total) ? rec.total : null
          });
        }
      }
      return Array.from(map.values()).sort((a, b) => a.date - b.date);
    }

    function renderChartLegend() {
      if (!chartLegend) return;
      chartLegend.innerHTML = metricConfigs.map(cfg => `
        <span class="legend-item">
          <span class="legend-swatch" style="background:${cfg.color};height:${cfg.lineWidth + 1}px;"></span>
          ${cfg.label}
        </span>
      `).join('');
    }

    function handleChartFilterClick(event) {
      const button = event.target.closest('button[data-range]');
      if (!button) return;
      currentChartRange = button.dataset.range || 'all';
      if (chartFilters) {
        chartFilters.querySelectorAll('button').forEach(btn => {
          btn.classList.toggle('active', btn === button);
        });
      }
      renderTrendChart();
    }

    function monthDiff(start, end) {
      if (!(start instanceof Date) || !(end instanceof Date)) return 0;
      return (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
    }

    function getFilteredSeries(range) {
      if (!monthlySeries.length) return [];
      const latest = monthlySeries[monthlySeries.length - 1].date;
      if (!latest) return monthlySeries.slice();
      if (range === 'ytd') {
        const targetYear = latest.getFullYear();
        return monthlySeries.filter(item => item.date.getFullYear() === targetYear);
      }
      if (range === 'all') return monthlySeries.slice();
      const windowMap = { '1m': 1, '3m': 3, '6m': 6, '1y': 12 };
      const months = windowMap[range];
      if (!months) return monthlySeries.slice();
      return monthlySeries.filter(item => monthDiff(item.date, latest) < months);
    }

    function renderTrendChart() {
      if (!chartCanvas || !chartCanvas.getContext) return;
      const ctx = chartCanvas.getContext('2d');
      const series = getFilteredSeries(currentChartRange);
      const width = chartCanvas.clientWidth || 600;
      const height = chartCanvas.height || 260;
      chartCanvas.width = width;
      chartCanvas.height = height;
      ctx.clearRect(0, 0, width, height);

      if (!series.length) {
        ctx.fillStyle = '#6b7280';
        ctx.font = '14px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
        ctx.fillText('No data to plot.', 16, height / 2);
        return;
      }

      const padding = { top: 20, right: 20, bottom: 40, left: 60 };
      const values = [];
      series.forEach(point => {
        metricConfigs.forEach(cfg => {
          const val = point[cfg.key];
          if (Number.isFinite(val)) values.push(val);
        });
      });
      if (!values.length) {
        ctx.fillStyle = '#6b7280';
        ctx.font = '14px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
        ctx.fillText('No data to plot.', 16, height / 2);
        return;
      }
      const minValue = Math.min(...values);
      const maxValue = Math.max(...values);
      const range = maxValue - minValue || 1;

      const basePlotWidth = width - padding.left - padding.right;
      const plotHeight = height - padding.top - padding.bottom;
      // Reserve horizontal breathing room so the last tooltip isn't clipped.
      const desiredRightGap = 60;
      const maxGapAllowed = Math.max(basePlotWidth - 20, 0);
      const extraRightGap = Math.min(desiredRightGap, maxGapAllowed);
      const usablePlotWidth = Math.max(basePlotWidth - extraRightGap, 0);
      const centeredWidth = Math.max(basePlotWidth, 0);

      const xPos = (index) => {
        if (series.length === 1) return padding.left + centeredWidth / 2;
        if (usablePlotWidth <= 0) return padding.left;
        return padding.left + (index / (series.length - 1)) * usablePlotWidth;
      };
      const yPos = (value) => padding.top + (maxValue - value) / range * plotHeight;

      ctx.strokeStyle = '#d0d7de';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding.left, padding.top);
      ctx.lineTo(padding.left, height - padding.bottom);
      ctx.lineTo(width - padding.right, height - padding.bottom);
      ctx.stroke();

      const ticks = 4;
      ctx.fillStyle = '#4b5563';
      ctx.font = '12px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
      for (let i = 0; i <= ticks; i++) {
        const value = minValue + (range / ticks) * i;
        const y = yPos(value);
        ctx.strokeStyle = '#e5e7eb';
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(width - padding.right, y);
        ctx.stroke();
        ctx.fillStyle = '#4b5563';
        ctx.fillText(formatUSD(value), 8, y + 4);
      }

      metricConfigs.forEach(cfg => {
        ctx.strokeStyle = cfg.color;
        ctx.lineWidth = cfg.lineWidth;
        ctx.beginPath();
        let started = false;
        series.forEach((point, index) => {
          const val = point[cfg.key];
          if (!Number.isFinite(val)) {
            started = false;
            return;
          }
          const x = xPos(index);
          const y = yPos(val);
          if (!started) {
            ctx.moveTo(x, y);
            started = true;
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.stroke();
      });

      metricConfigs.forEach(cfg => {
        ctx.fillStyle = cfg.color;
        series.forEach((point, index) => {
          const val = point[cfg.key];
          if (!Number.isFinite(val)) return;
          const x = xPos(index);
          const y = yPos(val);
          ctx.beginPath();
          ctx.arc(x, y, cfg.lineWidth + 1, 0, Math.PI * 2);
          ctx.fill();
        });
      });

      series.forEach((point, index) => {
        const x = xPos(index);
        ctx.fillStyle = '#374151';
        ctx.save();
        ctx.translate(x, height - padding.bottom + 15);
        ctx.rotate(-Math.PI / 12);
        ctx.fillText(point.label, -20, 0);
        ctx.restore();
      });
      pointTargets = {
        radius: 8,
        points: series.map((point, index) => ({
          x: xPos(index),
          y: metricConfigs.map(cfg => Number.isFinite(point[cfg.key]) ? yPos(point[cfg.key]) : null),
          data: point
        }))
      };
    }

    let pointTargets = { radius: 8, points: [] };

    function handleChartMouseMove(event) {
      if (!chartCanvas || !pointTargets.points.length) return;
      const rect = chartCanvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const radius = pointTargets.radius;
      let hovered = null;
      pointTargets.points.forEach(point => {
        point.y.forEach((yVal, idx) => {
          if (!Number.isFinite(yVal)) return;
          const dx = x - point.x;
          const dy = y - yVal;
          if (Math.sqrt(dx * dx + dy * dy) <= radius) {
            hovered = { point, metricIndex: idx };
          }
        });
      });
      if (!hovered) {
        hideTooltip();
        return;
      }
      showTooltip(event.clientX, event.clientY, hovered.point.data);
    }

    function showTooltip(clientX, clientY, dataPoint) {
      if (!chartTooltip) return;
      const tooltipContent = `
        <div style="font-weight:600;margin-bottom:0.25rem;">${dataPoint.label}</div>
        ${metricConfigs.map(cfg => Number.isFinite(dataPoint[cfg.key])
          ? `<div><span style="color:${cfg.key === 'total' ? '#ffffff' : cfg.color};font-weight:600;">${cfg.label}:</span> ${formatUSD(dataPoint[cfg.key])}</div>`
          : ''
        ).join('')}
      `;
      chartTooltip.innerHTML = tooltipContent;
      chartTooltip.style.opacity = '1';
      const wrapperRect = chartCanvas.parentElement?.getBoundingClientRect();
      const tooltipRect = chartTooltip.getBoundingClientRect();
      const offsetX = 12;
      const offsetY = 12;
      const left = wrapperRect ? clientX - wrapperRect.left + offsetX : clientX + offsetX;
      const top = wrapperRect ? clientY - wrapperRect.top + offsetY : clientY + offsetY;
      const clampedLeft = Math.min(Math.max(left, 0), (wrapperRect?.width || window.innerWidth) - (tooltipRect.width + 10));
      chartTooltip.style.left = `${clampedLeft}px`;
      chartTooltip.style.top = `${top}px`;
    }

    function hideTooltip() {
      if (chartTooltip) chartTooltip.style.opacity = '0';
    }

    function formatDateLabel(date) {
      if (!(date instanceof Date) || isNaN(date.getTime())) return '-';
      return date.toLocaleDateString('en-US');
    }

    function buildHierarchy(records) {
      const yearMap = new Map();
      for (const rec of records) {
        const year = rec.date.getFullYear();
        const monthIndex = rec.date.getMonth();
        const dayLabel = rec.date.getDate().toString().padStart(2, '0');
        if (!yearMap.has(year)) {
          yearMap.set(year, {
            key: String(year),
            label: String(year),
            diff: 0,
            months: [],
            monthMap: new Map(),
            lastRecord: null
          });
        }
        const yearNode = yearMap.get(year);
        yearNode.diff += rec.diff;
        yearNode.lastRecord = rec;

        const monthKey = `${year}-${String(monthIndex + 1).padStart(2, '0')}`;
        if (!yearNode.monthMap.has(monthKey)) {
          yearNode.monthMap.set(monthKey, {
            key: monthKey,
            label: formatMonthKey(`${year}-${String(monthIndex + 1).padStart(2, '0')}`),
            diff: 0,
            days: [],
            lastRecord: null
          });
        }
          const monthNode = yearNode.monthMap.get(monthKey);
        monthNode.diff += rec.diff;
        monthNode.lastRecord = rec;
        if (!monthNode.weeks) {
          monthNode.weeks = new Map();
        }
        const weekKey = `${monthKey}-W${getISOWeekNumber(rec.date)}`;
        if (!monthNode.weeks.has(weekKey)) {
          monthNode.weeks.set(weekKey, {
            key: weekKey,
            label: `Week ${getISOWeekNumber(rec.date)}`,
            diff: 0,
            days: [],
            lastRecord: null
          });
        }
        const weekNode = monthNode.weeks.get(weekKey);
        weekNode.diff += rec.diff;
        weekNode.lastRecord = rec;
        weekNode.days.push({
          key: `${weekKey}-${dayLabel}`,
          label: `${dayLabel}/${String(monthIndex + 1).padStart(2, '0')}`,
          single: rec.single,
          ira: rec.ira,
          trust: rec.trust,
          total: rec.total,
          diff: rec.diff
        });
      }

      const years = [];
      for (const yearNode of yearMap.values()) {
        yearNode.months = Array.from(yearNode.monthMap.values()).sort((a, b) => (a.key > b.key ? 1 : -1));
        yearNode.single = yearNode.lastRecord?.single ?? 0;
        yearNode.ira = yearNode.lastRecord?.ira ?? 0;
        yearNode.trust = yearNode.lastRecord?.trust ?? 0;
        yearNode.total = yearNode.lastRecord?.total ?? 0;
        for (const month of yearNode.months) {
          const monthWeeks = Array.from(month.weeks.values()).sort((a, b) => (a.key > b.key ? 1 : -1));
          month.weekList = monthWeeks;
          month.single = month.lastRecord?.single ?? 0;
          month.ira = month.lastRecord?.ira ?? 0;
          month.trust = month.lastRecord?.trust ?? 0;
          month.total = month.lastRecord?.total ?? 0;
          for (const week of monthWeeks) {
            week.single = week.lastRecord?.single ?? 0;
            week.ira = week.lastRecord?.ira ?? 0;
            week.trust = week.lastRecord?.trust ?? 0;
            week.total = week.lastRecord?.total ?? 0;
          }
          delete month.weeks;
          delete month.lastRecord;
        }
        delete yearNode.monthMap;
        delete yearNode.lastRecord;
        delete yearNode.monthMap;
        delete yearNode.lastRecord;
        years.push(yearNode);
      }
      return years.sort((a, b) => b.key.localeCompare(a.key));
    }

    function renderHierarchy() {
      if (!hierarchyBody) return;
      hierarchyBody.innerHTML = '';
      if (!hierarchyData.length) {
        hierarchyBody.innerHTML = `<tr><td colspan="6" class="table-empty">No data</td></tr>`;
        return;
      }

      const fragment = document.createDocumentFragment();
      for (const year of hierarchyData) {
        const yearRow = document.createElement('tr');
        yearRow.className = 'hierarchy-row year-row';
        const expanded = expandedYears.has(year.key);
        yearRow.innerHTML = `
          <td>
            <div class="level-label">
              ${year.months.length ? `<button class="tree-toggle" data-year="${year.key}" aria-label="Toggle year">${expanded ? '▾' : '▸'}</button>` : '<span class="indent"></span>'}
              ${year.label}
            </div>
          </td>
          <td>${formatUSD(year.single)}</td>
          <td>${formatUSD(year.ira)}</td>
          <td>${formatUSD(year.trust)}</td>
          <td>${formatUSD(year.total)}</td>
          <td class="${year.diff > 0 ? 'kpi-positive' : year.diff < 0 ? 'kpi-negative' : 'kpi-neutral'}">${formatUSD(year.diff)}</td>
        `;
        fragment.appendChild(yearRow);

        if (expanded) {
          for (const month of year.months) {
            const monthRow = document.createElement('tr');
            monthRow.className = 'hierarchy-row month-row';
            const monthExpanded = expandedMonths.has(month.key);
            monthRow.innerHTML = `
              <td>
                <div class="level-label">
                  <span class="indent"></span>
                  ${month.weekList.length ? `<button class="tree-toggle" data-month="${month.key}" aria-label="Toggle month">${monthExpanded ? '▾' : '▸'}</button>` : '<span class="indent"></span>'}
                  ${month.label}
                </div>
              </td>
              <td>${formatUSD(month.single)}</td>
              <td>${formatUSD(month.ira)}</td>
              <td>${formatUSD(month.trust)}</td>
              <td>${formatUSD(month.total)}</td>
              <td class="${month.diff > 0 ? 'kpi-positive' : month.diff < 0 ? 'kpi-negative' : 'kpi-neutral'}">${formatUSD(month.diff)}</td>
            `;
            fragment.appendChild(monthRow);

            if (monthExpanded) {
              for (const week of month.weekList) {
                const weekRow = document.createElement('tr');
                weekRow.className = 'hierarchy-row';
                const weekExpanded = expandedWeeks.has(week.key);
                weekRow.innerHTML = `
                  <td>
                    <div class="level-label">
                      <span class="indent"></span>
                      <span class="indent"></span>
                      ${week.days.length ? `<button class="tree-toggle" data-week="${week.key}" aria-label="Toggle week">${weekExpanded ? '▾' : '▸'}</button>` : '<span class="indent"></span>'}
                      ${week.label}
                    </div>
                  </td>
                  <td>${formatUSD(week.single)}</td>
                  <td>${formatUSD(week.ira)}</td>
                  <td>${formatUSD(week.trust)}</td>
                  <td>${formatUSD(week.total)}</td>
                  <td class="${week.diff > 0 ? 'kpi-positive' : week.diff < 0 ? 'kpi-negative' : 'kpi-neutral'}">${formatUSD(week.diff)}</td>
                `;
                fragment.appendChild(weekRow);

                if (weekExpanded) {
                  for (const day of week.days) {
                    const dayRow = document.createElement('tr');
                    dayRow.className = 'hierarchy-row';
                    dayRow.innerHTML = `
                      <td>
                        <div class="level-label">
                          <span class="indent"></span>
                          <span class="indent"></span>
                          <span class="indent"></span>
                          ${day.label}
                        </div>
                      </td>
                      <td>${formatUSD(day.single)}</td>
                      <td>${formatUSD(day.ira)}</td>
                      <td>${formatUSD(day.trust)}</td>
                      <td>${formatUSD(day.total)}</td>
                      <td class="${day.diff > 0 ? 'kpi-positive' : day.diff < 0 ? 'kpi-negative' : 'kpi-neutral'}">${formatUSD(day.diff)}</td>
                    `;
                    fragment.appendChild(dayRow);
                  }
                }
              }
            }
          }
        }
      }

      hierarchyBody.appendChild(fragment);
    }

    function handleHierarchyClick(event) {
      const yearBtn = event.target.closest('[data-year]');
      if (yearBtn) {
        const key = yearBtn.getAttribute('data-year');
        if (expandedYears.has(key)) {
          expandedYears.delete(key);
        } else {
          expandedYears.add(key);
        }
        renderHierarchy();
        return;
      }

      const monthBtn = event.target.closest('[data-month]');
      if (monthBtn) {
        const key = monthBtn.getAttribute('data-month');
        if (expandedMonths.has(key)) {
          expandedMonths.delete(key);
        } else {
          expandedMonths.add(key);
        }
        renderHierarchy();
        return;
      }

      const weekBtn = event.target.closest('[data-week]');
      if (weekBtn) {
        const key = weekBtn.getAttribute('data-week');
        if (expandedWeeks.has(key)) {
          expandedWeeks.delete(key);
        } else {
          expandedWeeks.add(key);
        }
        renderHierarchy();
      }
    }

    async function handleEntrySubmit(event) {
      event.preventDefault();
      const baseRecord = {
        date: parseExcelDate(formDate.value),
        single: parseCurrencyToNumber(formSingle.value),
        ira: parseCurrencyToNumber(formIRA.value),
        trust: parseCurrencyToNumber(formTrust.value)
      };
      if (!baseRecord.date || isNaN(baseRecord.date.getTime())) {
        showError('Invalid date for the new entry.');
        return;
      }
      const dateKey = formatDateForInput(baseRecord.date);
      if (!dateKey) {
        showError('Invalid date for the new entry.');
        return;
      }
      const duplicateIndex = currentRecords.findIndex(rec => formatDateForInput(rec.date) === dateKey);
      if (duplicateIndex !== -1 && duplicateIndex !== editingRecordIndex) {
        alert('Warning: There is already an entry for this date. Please edit the existing entry or choose another day.');
        return;
      }

      let working = currentRecords.map(rec => ({ ...rec }));
      if (editingRecordIndex !== null) {
        working.splice(editingRecordIndex, 1);
      }
      working = working.filter(rec => formatDateForInput(rec.date) !== dateKey);
      working.push(baseRecord);

      try {
        setSubmitButtonLoading(true);
        await sendEntryToGoogleSheet(baseRecord, editingRecordIndex !== null ? 'update' : 'insert');
        applyRecords(working);
        logDebug(editingRecordIndex !== null ? 'Edited existing entry.' : 'Added new entry.');
      } catch (err) {
        console.error(err);
        alert(`Failed to sync entry with Google Sheets: ${err.message || err}`);
      } finally {
        setSubmitButtonLoading(false);
      }
    }

    function handleCrudTableClick(event) {
      const button = event.target.closest('button[data-index]');
      if (!button) return;
      const index = Number(button.getAttribute('data-index'));
      if (Number.isNaN(index)) return;
      const action = button.getAttribute('data-action');
      if (action === 'edit') {
        startEditRecord(index);
      } else if (action === 'delete') {
        handleDeleteRecord(index);
      }
    }

    function startEditRecord(index) {
      const record = currentRecords[index];
      if (!record) return;
      editingRecordIndex = index;
      formDate.value = formatDateForInput(record.date);
        formSingle.value = formatUSD(record.single ?? 0);
        formSingle.dataset.rawValue = (record.single ?? 0).toString();
        formIRA.value = formatUSD(record.ira ?? 0);
        formIRA.dataset.rawValue = (record.ira ?? 0).toString();
        formTrust.value = formatUSD(record.trust ?? 0);
        formTrust.dataset.rawValue = (record.trust ?? 0).toString();
      submitEntryBtn.textContent = 'Update entry';
    }

    function resetFormState() {
      editingRecordIndex = null;
      if (entryForm) entryForm.reset();
      [formSingle, formIRA, formTrust].forEach(input => {
        if (input) {
          delete input.dataset.rawValue;
          input.value = '';
        }
      });
      submitEntryBtn.textContent = 'Add entry';
    }

    async function handleDeleteRecord(index) {
      const record = currentRecords[index];
      if (!record) return;
      const dateKey = formatDateForInput(record.date);
      if (!dateKey) return;
      const confirmDelete = window.confirm(`Delete entry dated ${dateKey}?`);
      if (!confirmDelete) return;
      try {
        setSubmitButtonLoading(true, 'Deleting...');
        await sendEntryToGoogleSheet(record, 'delete');
        const updated = currentRecords.filter((_, i) => i !== index);
        applyRecords(updated);
        logDebug('Removed entry.');
      } catch (err) {
        console.error(err);
        alert(`Failed to delete entry from Google Sheets: ${err.message || err}`);
      } finally {
        setSubmitButtonLoading(false);
      }
    }

    function setSubmitButtonLoading(isLoading, label = 'Saving...') {
      if (!submitEntryBtn) return;
      if (isLoading) {
        submitEntryBtn.dataset.prevLabel = submitEntryBtn.textContent;
        submitEntryBtn.textContent = label;
        submitEntryBtn.disabled = true;
      } else {
        if (submitEntryBtn.dataset.prevLabel) {
          submitEntryBtn.textContent = submitEntryBtn.dataset.prevLabel;
          delete submitEntryBtn.dataset.prevLabel;
        }
        submitEntryBtn.disabled = false;
      }
    }

    async function sendEntryToGoogleSheet(record, action = 'insert') {
      if (!GOOGLE_SCRIPT_ENDPOINT) {
        throw new Error('Google Script endpoint is not configured.');
      }
      const displayDate = new Date(record.date).toLocaleDateString('en-US');
      const payload = {
        action,
        dateISO: formatDateForInput(record.date),
        dateDisplay: displayDate,
        single: Number.isFinite(record.single) ? record.single : 0,
        ira: Number.isFinite(record.ira) ? record.ira : 0,
        trust: Number.isFinite(record.trust) ? record.trust : 0,
        token: GOOGLE_SCRIPT_TOKEN
      };
      const response = await fetch(GOOGLE_SCRIPT_ENDPOINT, {
        method: 'POST',
        headers: { 'Content-Type': 'text/plain;charset=utf-8' },
        body: JSON.stringify(payload)
      });
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      let data = null;
      try {
        data = await response.json();
      } catch (err) {
        // Some deployments might not return JSON; ignore parsing errors if content empty
      }
      if (data && data.success === false) {
        throw new Error(data.error || 'Unknown error from Google Script');
      }
      return data;
    }

    function handleDownloadCsv() {
      if (!currentRecords.length) {
        showError('No local data to export.');
        return;
      }
      const header = ['Date', 'Single', 'IRA', 'Trust Acct'];
      const rows = currentRecords.map(rec => [
        formatDateForInput(rec.date),
        (rec.single ?? 0).toString(),
        (rec.ira ?? 0).toString(),
        (rec.trust ?? 0).toString()
      ]);
      const csv = [header.join(','), ...rows.map(r => r.join(','))].join('\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `finance-updated-${Date.now()}.csv`;
      link.click();
      URL.revokeObjectURL(url);
      logDebug('CSV exported for manual upload.');
    }

    function renderCrudTable() {
      if (!crudTableBody) return;
      crudTableBody.innerHTML = '';
      if (!currentRecords.length) {
        crudTableBody.innerHTML = `<tr><td colspan="7" class="table-empty">No data loaded.</td></tr>`;
        if (toggleEntriesBtn) {
          toggleEntriesBtn.style.display = 'none';
          toggleEntriesBtn.setAttribute('aria-expanded', 'false');
        }
        return;
      }
      const fragment = document.createDocumentFragment();
      const sortedRecords = currentRecords
        .map((rec, index) => ({ rec, index }))
        .sort((a, b) => {
          const timeA = a.rec.date instanceof Date ? a.rec.date.getTime() : 0;
          const timeB = b.rec.date instanceof Date ? b.rec.date.getTime() : 0;
          return timeB - timeA;
        });
      const shouldClampRows = sortedRecords.length > MAX_CRUD_VISIBLE_ROWS;
      if (toggleEntriesBtn) {
        if (shouldClampRows) {
          toggleEntriesBtn.style.display = 'inline-flex';
          toggleEntriesBtn.textContent = showAllCrudRows ? 'Show less ▴' : 'Show more ▾';
          toggleEntriesBtn.setAttribute('aria-expanded', showAllCrudRows ? 'true' : 'false');
        } else {
          toggleEntriesBtn.style.display = 'none';
          toggleEntriesBtn.setAttribute('aria-expanded', 'false');
          showAllCrudRows = false;
        }
      }
      sortedRecords.forEach(({ rec, index }, rowIndex) => {
        const tr = document.createElement('tr');
        const shouldHideRow = shouldClampRows && !showAllCrudRows && rowIndex >= MAX_CRUD_VISIBLE_ROWS;
        tr.innerHTML = `
          <td>${formatDateLabel(rec.date)}</td>
          <td>${formatUSD(rec.single)}</td>
          <td>${formatUSD(rec.ira)}</td>
          <td>${formatUSD(rec.trust)}</td>
          <td>${formatUSD(rec.total)}</td>
          <td class="${rec.diff > 0 ? 'kpi-positive' : rec.diff < 0 ? 'kpi-negative' : 'kpi-neutral'}">${formatUSD(rec.diff)}</td>
          <td class="crud-table-actions">
            <button data-action="edit" data-index="${index}">Edit</button>
            <button data-action="delete" data-index="${index}">Delete</button>
          </td>
        `;
        if (shouldHideRow) {
          tr.style.display = 'none';
        }
        fragment.appendChild(tr);
      });
      crudTableBody.appendChild(fragment);
    }

    function formatDateForInput(date) {
      if (!(date instanceof Date) || isNaN(date.getTime())) return '';
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }
  </script>
</body>
</html>
